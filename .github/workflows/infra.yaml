name: Infrastructure Pipeline

on:
  workflow_dispatch:
  
  push:
    branches:
      - dev

  pull_request:
    branches:
      - main

env:
    AWS_REGION: us-east-1
    
jobs:
  
  detect-changes:
    name: Detect Infrastructure changes
    runs-on: ubuntu-latest
    outputs:
      infra_changed: ${{ steps.detect_changes.outputs.infra }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect infra changes
        id : detect_changes
        uses: dorny/paths-filter@v3
        with:
          base: ${{ github.event.before }}
          filters: |
            infra:
              - 'infra/**/*.tf'
              - 'infra/**/*.tfvars'
  
  terraform:
    name: Provision AWS Infrastructure
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Terraform Init
        working-directory: ./infra
        run: terraform init
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
      
      - name: Terraform Validate
        working-directory: ./infra
        run: terraform validate
      
      - name: Terraform Plan
        working-directory: ./infra
        run: terraform plan
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
      
      - name: Terraform Apply
        working-directory: ./infra
        run: terraform apply -auto-approve
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
      
      - name: Display All Terraform Outputs
        id: terraform_outputs
        working-directory: ./infra
        run: |
          terraform output

          EKS_CLUSTER=$(terraform output -raw eks_cluster_name)
          DB_ENDPOINT=$(terraform output -raw db_endpoint)
          
          echo "eks_cluster_name=$EKS_CLUSTER" >> $GITHUB_OUTPUT
          echo "db_endpoint=$DB_ENDPOINT" >> $GITHUB_OUTPUT
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
      
      - name: Configure kubectl for EKS
        run: |
          aws eks update-kubeconfig \
            --name ${{ steps.terraform_outputs.outputs.eks_cluster_name }} \
            --region ${{ env.AWS_REGION }}
          
          echo "Cluster info:"
          kubectl cluster-info
          
          echo "Cluster nodes:"
          kubectl get nodes
      
      - name: Install ArgoCD
        run: |
          echo "Creating ArgoCD namespace..."
          kubectl create namespace argocd || echo "Namespace already exists"
          
          echo "Installing ArgoCD..."
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          
          echo "Waiting for ArgoCD components to be ready..."
          kubectl wait --for=condition=available --timeout=600s \
            deployment/argocd-server \
            deployment/argocd-repo-server \
            deployment/argocd-applicationset-controller \
            -n argocd
          
          echo "ArgoCD installed successfully"
      
      - name: Expose ArgoCD Server
        run: |
          echo "Patching ArgoCD server service to LoadBalancer..."
          kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'
          
          echo "Waiting for LoadBalancer provisioning..."
          sleep 60
          
          ARGOCD_SERVER=$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "ArgoCD Server URL: http://$ARGOCD_SERVER"
      
      - name: Retrieve ArgoCD Admin Password
        id: argocd_password
        run: |
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          
          echo "ArgoCD Credentials"
          echo "URL: http://$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')"
          echo "Username: admin"
          echo "Password: $ARGOCD_PASSWORD"

      - name: Create Application Namespace
        run: |
          echo "Creating application namespace..."
          kubectl create namespace puddle-production || echo "Namespace already exists"
      
      - name: Create Database Secret
        run: |
          echo "Creating database secret..."
          kubectl create secret generic puddle-db-secret \
            --from-literal=DATABASE_URL="postgresql://${{ secrets.DB_USERNAME }}:${{ secrets.DB_PASSWORD }}@${{ steps.terraform_outputs.outputs.db_endpoint }}/${{ secrets.DB_NAME }}" \
            --namespace=puddle-production \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "Database secret created"
      
      - name: Create Application Secrets
        run: |
          echo "Creating application secrets..."
          kubectl create secret generic puddle-app-secret \
            --from-literal=DJANGO_SECRET_KEY="${{ secrets.DJANGO_SECRET_KEY }}" \
            --from-literal=AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
            --from-literal=AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            --namespace=puddle-production \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "Application secrets created"
      
      - name: Deploy ArgoCD Application
        run: |
          echo "Deploying ArgoCD Application manifest..."
          kubectl apply -f argocd/application.yaml
          
          echo "Waiting for application to sync..."
          sleep 10
          
          echo "ArgoCD Application Status:"
          kubectl get application puddle-app -n argocd
      
      - name: Infrastructure Setup Summary
        run: |
          echo "Infrastructure Setup Complete"
          echo ""
          echo "AWS Resources Provisioned:"
          echo "  - VPC with public/private subnets"
          echo "  - EKS Cluster: ${{ steps.terraform_outputs.outputs.eks_cluster_name }}"
          echo "  - RDS Database: ${{ steps.terraform_outputs.outputs.db_endpoint }}"
          echo "  - S3 Bucket for media files"
          echo "  - ECR Repository for Docker images"
          echo ""
          echo "ArgoCD Configuration:"
          echo "  - Installed in argocd namespace"
          echo "  - Exposed via LoadBalancer"
          echo "  - Application manifest deployed"
          echo ""
          echo "Kubernetes Secrets Created:"
          echo "  - puddle-db-secret (database credentials)"
          echo "  - puddle-app-secret (application secrets)"
          echo ""
          echo "Next Steps:"
          echo "  1. Add ARGOCD_PASSWORD to GitHub Secrets"
          echo "  2. Run CI/CD pipeline to deploy application"