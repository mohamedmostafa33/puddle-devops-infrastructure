name: CI Pipeline

on:
  workflow_dispatch:

  push:
    branches:
      - main

  pull_request:
    branches:
      - main

env:
    AWS_REGION: us-east-1
    AWS_BUCKET_NAME: puddle-s3-media-nti
    AWS_S3_REGION_NAME: us-east-1
    AWS_S3_CUSTOM_DOMAIN: puddle-s3-media-nti.s3.amazonaws.com
    USE_S3: true
    
jobs:

  detect-changes:
    name: Detect Application changes
    runs-on: ubuntu-latest
    outputs:
      app_changed: ${{ steps.filter.outputs.app }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Check for Application changes 
        id: filter
        uses: dorny/paths-filter@v3
        with:
          base: ${{ github.event.before }}
          filters: |
            app:
              - 'src/**'

  build:
    name: Build and Test Application
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r src/requirements.txt
          pip install coverage

      - name: Create .env file
        working-directory: src
        run: |
          cat > .env << EOF
          DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}
          DJANGO_DEBUG=False
          DJANGO_ALLOWED_HOSTS=localhost,127.0.0.1
          DJANGO_CSRF_TRUSTED_ORIGINS=http://localhost
          DATABASE_URL=sqlite:///db.sqlite3
          DJANGO_EMAIL_BACKEND=django.core.mail.backends.console.EmailBackend
          DJANGO_SECURE=False
          USE_S3=${{ env.USE_S3 }}
          AWS_BUCKET_NAME=${{ env.AWS_BUCKET_NAME }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_S3_REGION_NAME=${{ env.AWS_S3_REGION_NAME }}
          AWS_S3_CUSTOM_DOMAIN=${{ env.AWS_S3_CUSTOM_DOMAIN }}
          EOF

      - name: Collect static files
        working-directory: src
        run: |
          python manage.py collectstatic --noinput

      - name: Run Django tests with coverage
        working-directory: src
        run: |
          coverage run --source='.' manage.py test
          coverage report
          coverage xml -o coverage.xml

      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v6
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      - name: SonarQube Quality Gate Check
        uses: SonarSource/sonarqube-quality-gate-action@v1
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

  docker:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Get commit SHA
        id: get-sha
        run: echo "COMMIT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_ENV

      - name: Build Docker image with commit SHA
        run: |
          docker build -t puddle-app:v${{ env.COMMIT_SHA }} -f src/Dockerfile ./src

      - name: Tag Docker image for ECR
        run: |
          docker tag puddle-app:v${{ env.COMMIT_SHA }} ${{ secrets.ECR_URL }}:${{ env.COMMIT_SHA }}
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_URL }}
      
      - name: Push Docker image to ECR
        run: |
          docker push ${{ secrets.ECR_URL }}:${{ env.COMMIT_SHA }}
          echo "Pushed: ${{ secrets.ECR_URL }}:${{ env.COMMIT_SHA }}"

      - name: Update helm values file
        run: |
          sed -i 's|image: .*|image: '"${{ secrets.ECR_URL }}:${{ env.COMMIT_SHA }}"'|g' helm/values.yaml

          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/dev" ]]; then
            git config --global user.name "github-actions"
            git config --global user.email "github-actions@github.com"
            git add helm/values.yaml
            git commit -m "chore(tag): update Docker image tag to ${{ env.COMMIT_SHA }}" || echo "No changes to commit"
            git pull origin --rebase dev || true
            git push origin dev || echo "Nothing to push"
          else
            echo "Skipping git push for PR - values.yaml updated locally only"
          fi

  deploy:
    name: Trigger ArgoCD Deployment
    runs-on: ubuntu-latest
    needs: [docker]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: dev  
      
      - name: Get commit SHA
        run: echo "COMMIT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl for EKS
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
          kubectl config current-context
      
      - name: Check if ArgoCD is installed
        id: check_argocd
        run: |
          if kubectl get namespace argocd &> /dev/null; then
            echo "argocd_installed=true" >> $GITHUB_OUTPUT
            echo "ArgoCD is installed"
          else
            echo "argocd_installed=false" >> $GITHUB_OUTPUT
            echo "ArgoCD is not installed yet"
          fi

      - name: Install ArgoCD CLI
        if: steps.check_argocd.outputs.argocd_installed == 'true'
        run: |
          curl -sSL -o /tmp/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 /tmp/argocd /usr/local/bin/argocd
          argocd version --client

      - name: Login to ArgoCD
        if: steps.check_argocd.outputs.argocd_installed == 'true'
        run: |
          ARGOCD_SERVER=$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "ArgoCD Server: $ARGOCD_SERVER"
          
          argocd login $ARGOCD_SERVER \
            --username admin \
            --password ${{ secrets.ARGOCD_PASSWORD }} \
            --insecure \
            --grpc-web

      - name: Sync ArgoCD Application
        if: steps.check_argocd.outputs.argocd_installed == 'true'
        run: |
          echo "Checking for existing operations..."
          argocd app terminate-op puddle-app || echo "No operation to terminate"
          
          echo "Waiting for termination to complete..."
          sleep 30
          
          echo "Verifying operation termination..."
          for i in {1..6}; do
            if ! argocd app get puddle-app --show-operation 2>/dev/null | grep -q "inProgress"; then
              echo "Operation terminated successfully"
              break
            fi
            echo "Waiting for operation to terminate... attempt $i/6"
            sleep 5
          done
          
          echo "Triggering ArgoCD sync for puddle-app..."
          argocd app sync puddle-app --force --prune
          
          echo "Waiting for sync to complete..."
          argocd app wait puddle-app --timeout 600 --health

      - name: Get Application Status
        if: steps.check_argocd.outputs.argocd_installed == 'true'
        run: |
          echo "Application Status:"
          argocd app get puddle-app
          
          echo ""
          echo "Deployed Resources:"
          argocd app resources puddle-app

      - name: Verify Deployment
        if: steps.check_argocd.outputs.argocd_installed == 'true'
        run: |
          echo "Verifying deployment in cluster..."
          kubectl get pods -n puddle-production -l app=puddle-app
          kubectl get svc -n puddle-production
          
          echo ""
          echo "Image deployed: ${{ secrets.ECR_URL }}:${{ env.COMMIT_SHA }}"
      
      - name: Deployment Summary
        if: steps.check_argocd.outputs.argocd_installed == 'true' && success()
        run: |
          echo "Deployment completed successfully!"
          echo "Image: ${{ secrets.ECR_URL }}:${{ env.COMMIT_SHA }}"
          echo "Check ArgoCD UI for details"
          
          SERVICE_URL=$(kubectl get svc puddle-app-service -n puddle-production -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "pending")
          echo "Service URL: http://$SERVICE_URL"
      
      - name: ArgoCD Not Installed Notice
        if: steps.check_argocd.outputs.argocd_installed == 'false'
        run: |
          echo "ArgoCD is not installed on the cluster yet!"
          echo ""
          echo "To install ArgoCD, run:"
          echo "   1. Configure kubectl: aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}"
          echo "   2. Run: ./argocd/install-argocd.sh"
          echo "   3. Add ARGOCD_PASSWORD to GitHub Secrets"
          echo ""
          echo "Docker image has been built and pushed to ECR:"
          echo "   ${{ secrets.ECR_URL }}:${{ env.COMMIT_SHA }}"